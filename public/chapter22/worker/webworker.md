# HTML5 API

## 웹 워커
- 클라이언트 측 JS의 기본적인 특징 중 하나는 __싱글 스레드로 처리__ 된다는 점.
- 브라우저는 두 이벤트 핸들러를 동시에 수행할 수 없어!
- 예를 들어, 이벤트 핸들러가 실행되는 중에는 타이머가 발생되지 않을 것이다.
- 애플리케이션의 상태나 문서를 동시에 업데이트 하기는 불가능
- __클라이언트 측 JS함수는 실행 시간이 너무 길면 안된다!!!!__
- 너무 오랫동안 수행되는 함수는 이벤트 순환을 정체시켜 웹브라우저가 사용자의 입력에 응답하지 않게 만들것이다.
- Ajax API가 항상 비동기적으로 수행되는 이유, 이렇기 때문에 클라이언트 측 JS는 간단히 동기방식으로  
라이브러리를 불러오는 load() 또는 require() 같은 함수가 존재할 수 없다!!
- 웹 워커에서는 클라이언트 측 JS의 __단일 스레드를 느슨하게__ 만듦.
- '워커'는 효과적으로 병렬 스레드를 실행하도록 정의.
- 웹 워커는 자체적으로 생성한 실행 환경에 존재
- but, window 또는 document객체에 접근하지 않고, 오직 비동기 메시지 전달을 통해서만 메인 스레드와 통신할 수 있다.
- 즉, DOM의 변경을 동시에 수행하기가 가능하진 않지만, __API를 동기적으로 사용할 수 있고  
이벤트 순환을 방해하지 않고 브라우저도 중단시키지 않은 채 오랜동안 실행되는 함수를 작성할수도 있다.__
- 새 워커를 만드는 과정이 새 브라우저 창을 띄우는 것과 같이 무거운 작업은 X
- 그렇다고 워커가 가벼운 스레드와 같은 것도 아니므로 사소한 작업을 수행하기 위해 새 워커를 만드는 것은 의미가 없음.
- 복잡한 웹 애플리케이션에서는 다수의 워커를 생성하는 편이 유용할 수 도 있겠지만  
수백, 수천개의 워커를 사용하는 애플리케이션이 반드시 실용적이지는 않아!
- 1 ) Worker 객체로써, 생성된 스레드를 외부에서 바라보는 모습.
- 2 ) WorkerGlobalScope : 새 워커를 위한 전역 객체, 워커 스레드 자체를 내부에서 보는 모습과도 같다.

### Worker 객체
- 새 워커를 만들려면 Worker 생성자에 워커가 실행되는 JS코드 URL을 지정.
```
var worker = new Worker("utils/loader.js");
```
- Worker객체를 한번 생성하면 postMesaage()를 활용하여 데이터를 전송.
- postMessage()에 전달하는 값은 복제되며 해당 복사본은 message 이벤트를 통해 워커에 전달될 것이다.
```
worker.postMessage("file.txt");
```
- 워커의 postMessage()메서드와 Window객체의 postMessage()메서드와 같은 출처에 대한 전달인자가 존재하지 않는다.
- window.postMessage()는 메시지의 형태를 문자열로 제한,  
but, 워커의 postMessage()메서더는 메시지 객체를 정확하게 복제(최신 브라우저에서)
```
// Worker객체의 message이벤트를 등록시키면 워커로부터 메시지를 전달받을 수 있다.
worker.onmessage = function (e) {
    var message = e.data;
    console.log("URL contents: " + message);
};

// 워커가 예외를 발생시켰으나 내부적으로 처리되지 않았다면 ,해당 예외는 구독(?)가능한 다른 이벤트로 전파
worker.onerror = function (e) {
    console.log(e.filename + '파일의 : ' + e.lineno + ': 에서 ' + e.message + ' 오류가 발생하였습니다.');
};
```
- 이밖에 Worker 객체의 메서드는 teminate() : 워커 스레드를 강제로 종료

### 워커 실행 모델
- 워커 스레드는 동기 방식으로 해당 코드와 포함괸 모든 스크립트를 위에서 아래로 실행.
- 그런 다음, 이벤트와 타이머에 비동기적으로 응답하는 단계로 진입.
- 워커가 onmessage 이벤트에 핸들러를 등록하였다면 message이벤트가 도착하기 전까지는 절대로 워커가 종료되지 않음.  
but, 워커가 message 이벤트를 등록하고 있지 않다면, 대기중인 다운로드나 타이머와 같은 작업과 모든 콜백 관련 작업의 호출이  
완료될 때까지만 실행될 것임.
- 등록된 모든 콜백이 완료되면, 워커가 새로운 작업을 시작할 수 없으므로 스레드는 안전하게 종료된다.
- ex) XMLHttpRequest를 사용하여 onmessage이벤트 핸들러를 사용하지 않고 파일을 다운로드하는 워커를 생각해보자!  
새 다운로드를 시작하기 위해 onload이벤트 핸들러를 사용하거나 setTimeout()을 활용하는 타임아웃을 등록하면,  
스레드는 새 작업을 시작하고 실행을 유지할 것이다. but, 핸들러나 타임아웃 등이 존재하지 않는다면,  
스레드도 즉시 종료될 것이다.

### Worker의 범위
- Worker() 생성자를 활용하여 새 워커를 생성할 때는 해당 JS코드를 포함하는 파일의 URL을 지정해야함.
- 해당 워커 코드는 워커를 생성한 스크립트로부터 완전히 독립적인 새로운 순수 JS실행 환경에서 구동
- 이 새로운 실행 환경의 전역 객체는 WorkerGlobalScope 객체.
- WorkerGlobalScope는 순수 JS 전역 객체에는 없는 프로퍼티들을 포함하고 있지만 클라이언트측 window객체 전체의 크기보다는 작다.

#### WorkerGlobalScope
- 워커 내부에서 postMessage()를 호출하면 워커의 외부에 message 이벤트를 발생.
- 외부에서 전송된 메시지들은 onmessage핸들러의 이벤트 객체로 전달.
- WorkerGlobalScope가 워커의 전역 객체이기때문에, postMessage()와 onmessage는 워커코드에서 전역 함수 또는 전역 변수처럼 보임.
- close() 는 워커가 스스로 종료하게 되며, Worker.terminate() 메서드와 비슷한 역할.  
but, Worker객체에는 워커가 스스로 종료되었는지 스스로 검증할 수 있는 API가 존재X, onclose 이벤트 핸들러 프로퍼티에도 존재X.
- 이미 종료된 워커의 postMessage()를 호출하면 해당 메시지는 에러도 발생시키지 않은 채 조용히 취소되어 버릴것이다.
- 워커에 자체적으로 close()를 호출하는 코드가 있을때에는, 대체로 종료되기 전에 일종의 'closing'메시지를 전송하는 것이 좋은 방법!

##### importScripts()
- WorkerGlobalScope에 정의된 메소드
- 워커에서 필요한 라이브러리 코드를 불러들이는데 사용
- 하나 이상의 참조할 JS코드 파일의 URL을 전달인자로 받아들임.
```
// 코드를 작성하기 전에 먼저 필요한 클래스와 유틸리티를 불러들인다.
importScripts("collections/Set.js", "collections/Map.js", "utils/base64.js");
```
- 상대URL은 Worker() 생성자에서 지정한 URL을 기준으로 해석.
- 한 파일이 로드된 다음 실행되면, 지정한 순서에 따라 다음 파일을 불러들인다.
- 스크립트 파일을 불러오는 과정에서 네트워크 오류가 발생하거나 파일 중 하나가 실행 중 오류를 발생시키면  
나머지 스크립트들은 로드되거나 실행되지 않는다.
- importScripts()를 사용하여 불러온 스크립트에서도 importScripts()를 사용해 자체적으로 의존하는 파일들을 로드할 수 있다.  
but, 이미 로드된 스크립트에 대한 기록을 보관하지 않으므로 의존성 순환을 보호하는 장치가 전혀 없음!!주의할것!
- 동기방식으로 동작하므로 지정된 모든 스크립트가 로드되고 실행되기 전까지는 반환되지 않음.
- importScripts() 함수가 반환되면 로드된 스크립트를 즉시 사용 가능.
- 콜백 또는 이벤트 핸들러 필요X
- __메인 스레드의 이벤트 순환에 방해받지 않는 차단된 함수를 사용할 수 있고 다른 워커들이 동시에 수행되더라도 연산이 중단되지 않음.__
- 워커의 전역객체이므로, 해당 전역객체에는 JSON Object, isNaN(), Date()같은 주요 전역 객체 존재
- WorkerGlobalScope는 다음과 같은 클라이언트측 window객체 프로퍼티들이 존재


